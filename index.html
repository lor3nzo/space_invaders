<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Space Invaders (1978 homage) – Mobile Optimized</title>
<style>
  :root{
    --bg:#000; --fg:#20ff6c; --accent:#ff2a2a; --scanline: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background: radial-gradient(1200px 600px at 50% -20%, #021 0%, #000 60%) fixed, var(--bg);
    color:var(--fg); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    display:grid; place-items:center;
    padding: max(8px, env(safe-area-inset-top)) max(8px, env(safe-area-inset-right)) max(86px, env(safe-area-inset-bottom)) max(8px, env(safe-area-inset-left));
  }
  .cabinet{
    position:relative;
    /* Responsive sizing: keep 4:3 aspect, fit within viewport */
    width: min(96svw, 1100px);
    height: min(78svh, calc((96svw) * 0.75)); /* preserve 4:3 */
    aspect-ratio: 4 / 3;
    padding: clamp(.5rem, 1.2vw, 1rem);
    background:linear-gradient(180deg, #111, #000);
    border-radius: 18px; box-shadow: 0 30px 80px rgba(0,0,0,.7), inset 0 0 0 2px #151515, inset 0 0 30px #010;
  }
  header, footer{
    position:absolute; left:0; right:0; display:flex; justify-content:space-between; gap:.5rem;
    padding:.35rem .8rem; font-size:clamp(10px, 1.8vw, 14px); letter-spacing:.06em; opacity:.9; pointer-events:none;
  }
  header{top:.25rem}
  footer{bottom:.25rem}
  .light{color:#b0ffb0}
  .danger{color:var(--accent)}
  .btn{ border:1px solid #1f1; padding:.4rem .7rem; border-radius:10px; cursor:pointer; background:#010; color:var(--fg); box-shadow: inset 0 0 8px #020; user-select:none; transition:transform .05s; }
  .btn:active{ transform:translateY(1px) scale(.99) }
  canvas{
    width:100%; height:100%; display:block; background:#000; border-radius:12px; outline:1px solid #0f2; image-rendering: pixelated; box-shadow: inset 0 0 40px rgba(32,255,108,.08), inset 0 0 3px #093;
    touch-action:none; /* allow custom gestures */
  }
  .scan{ pointer-events:none; position:absolute; inset:0; border-radius:12px; background:
      repeating-linear-gradient(transparent 0 2px, var(--scanline) 2px 3px),
      radial-gradient(1200px 600px at 50% -20%, transparent 0%, rgba(0,0,0,.35) 55%, rgba(0,0,0,.75) 75%),
      linear-gradient(180deg, rgba(255,255,255,.04), transparent 30%, transparent 70%, rgba(0,0,0,.3));
    mix-blend-mode: screen; opacity:.9; }
  .marquee{ position:absolute; inset:0; display:grid; place-items:center; text-align:center; padding:1rem; background:#000; color:var(--fg); border-radius:12px;}
  .marquee.hidden{ display:none; }
  h1{margin:.2rem 0 .6rem 0; font-weight:800; font-size:clamp(18px,4.2vw,34px); letter-spacing:.04em}
  .small{opacity:.85; font-size:clamp(.9rem, 1.8vw, 1rem)}
  .row{display:flex; gap:.5rem; align-items:center; justify-content:center; flex-wrap:wrap}
  .kbd{border:1px solid #1f1; padding:.1rem .35rem; border-radius:6px; background:#010; font-weight:700}

  /* On-screen mobile controls */
  .touch-controls{ position:fixed; left:0; right:0; bottom: max(8px, env(safe-area-inset-bottom)); display:none; gap:10px; justify-content:space-between; padding: 8px 12px; z-index:5; }
  .btn-pad{ flex:1; min-height:56px; border-radius:12px; border:1px solid #0f4; background:#021; color:#bff; font-weight:800; font-size:clamp(14px, 4.2vw, 18px); box-shadow: 0 6px 20px rgba(0,0,0,.45), inset 0 0 10px #053; }
  .btn-pad:active{ transform:translateY(1px) }
  @media (hover: none) and (pointer: coarse){ .touch-controls{ display:flex } body{ padding-bottom: max(120px, env(safe-area-inset-bottom)); } }
</style>
</head>
<body>
  <div class="cabinet" id="cabinet">
    <header>
      <div>SCORE <span id="score" class="light">0000</span></div>
      <div>HI-SCORE <span id="hiscore" class="light">0000</span></div>
      <div>LIVES <span id="lives" class="light">3</span></div>
    </header>

    <canvas id="game" width="480" height="360" aria-label="Space Invaders game area"></canvas>
    <div class="scan" aria-hidden="true"></div>

    <div id="marquee" class="marquee">
      <div>
        <h1>SPACE INVADERS</h1>
        <p class="small">TAITO 1978 • Midway (overseas)</p>
        <p class="small" style="margin-top:.8rem">Bonus <span class="light">MYSTERY SHIP</span> • Shields • Descending Fleet • 10/20/30 Scoring</p>
        <div class="row" style="margin-top:1rem">
          <div class="kbd">←</div>
          <div class="kbd">→</div>
          <div class="kbd">SPACE</div>
          <div class="kbd">P</div>
          <div class="kbd">R</div>
        </div>
        <div class="row small" style="margin-top:.25rem">
          <div>Move</div><div>•</div><div>Fire</div><div>•</div><div>Pause</div><div>•</div><div>Reset</div>
        </div>
        <div class="row" style="margin-top:1rem">
          <button class="btn" id="startBtn">INSERT COIN • START</button>
        </div>
      </div>
    </div>

    <footer>
      <div>⏯ <span id="status" class="light">READY</span></div>
      <div>BONUS at <span class="light">1500</span>.  Mystery ship <span class="danger">?</span></div>
    </footer>
  </div>

  <!-- On-screen controls for mobile -->
  <div class="touch-controls" aria-hidden="false">
    <button class="btn-pad" id="leftBtn">⟵ LEFT</button>
    <button class="btn-pad" id="fireBtn">FIRE</button>
    <button class="btn-pad" id="rightBtn">RIGHT ⟶</button>
  </div>

<script>
(() => {
  const cabinet = document.getElementById('cabinet');
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const BASE_W = 480, BASE_H = 360; // logical game size
  let W = canvas.width, H = canvas.height;

  const ui = {
    score: document.getElementById('score'),
    hiscore: document.getElementById('hiscore'),
    lives: document.getElementById('lives'),
    status: document.getElementById('status'),
    marquee: document.getElementById('marquee'),
    startBtn: document.getElementById('startBtn'),
    leftBtn: document.getElementById('leftBtn'),
    rightBtn: document.getElementById('rightBtn'),
    fireBtn: document.getElementById('fireBtn'),
  };

  const mobile = matchMedia('(hover: none) and (pointer: coarse)').matches;

  // Resize: keep canvas internal res matching base; CSS handles scaling. Also handle orientation.
  function resize(){
    // Maintain logical size for gameplay consistency
    canvas.width = BASE_W; canvas.height = BASE_H; W = BASE_W; H = BASE_H;
  }
  addEventListener('resize', resize); resize();

  const PX = 2; // sprite pixel size

  // --- WebAudio minimal synth for authentic-feel bleeps ---
  const Audio = {
    ctx: null,
    gain: null,
    unlocked:false,
    ensure(){
      if(this.ctx) return;
      const a = this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.gain = a.createGain();
      this.gain.gain.value = 0.08; // global volume
      this.gain.connect(a.destination);
    },
    unlock(){ if(this.ctx && this.ctx.state === 'suspended'){ this.ctx.resume(); } this.unlocked = true; },
    beep(freq=440, dur=0.08, type='square', when=0){
      this.ensure();
      const t = this.ctx.currentTime + (when||0);
      const o = this.ctx.createOscillator();
      o.type = type; o.frequency.value = freq;
      const g = this.ctx.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.3, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
      o.connect(g); g.connect(this.gain);
      o.start(t); o.stop(t + dur + 0.02);
    },
    marchStep(i, alive){ const base = [110, 98, 87, 78][i%4]; const scale = Math.max(1, 40/(Math.max(1, alive)) ); this.beep(base*scale, 0.06, 'square'); },
    playerShot(){ this.beep(880, 0.05, 'square'); },
    invaderExplode(){ this.beep(140, 0.12, 'sawtooth'); },
    playerExplode(){ this.beep(90, 0.3, 'triangle'); },
    saucer(){ this.beep(520, 0.2, 'sine'); },
    saucerHit(){ this.beep(300, 0.18, 'triangle'); },
  };

  // --- Game State ---
  const state = {
    running:false, paused:false, frame:0,
    score:0, hiscore: Number(localStorage.getItem('si_hiscore')||0),
    lives:3, level:1,
    keys: {left:false,right:false,shoot:false},
    player: {x: W/2, y: H-28, w: 18, h: 10, speed: 2.0, dead:false, reload:0},
    bullets: [], enemyBullets: [], shields: [],
    fleet: {dir:1, left:48, top:48, cols:11, rows:5, alive:[], stepIndex:0, aliveCount:55, lastStep:0, stepInterval:420},
    saucer: {x:-100, y:34, w: 22, h:10, active:false, dir:1, timer: 900+Math.random()*900},
  };

  // --- Sprites ---
  const SPRITES = {
    player: ["001000100","011111110","111111111","111111111","101111101","001111100"],
    invTop: ["00111100","01111110","11111111","11011011","00111100","00100100"], // 30
    invMid: ["01100110","11111111","11000011","11111111","01011010","10000001"], // 20
    invBot: ["0011100","0111110","1100111","1111111","0101100","1010010"],      // 10
    shield: ["111111111111","111111111111","111111111111","111111111111","111111111111","111111111111"],
    saucer: ["001111111100","011111111110","111111111111","111011110111","011111111110","001111111100"],
    boom:["010","101","010"],
  };
  const SCORE_BY_TYPE = { invTop:30, invMid:20, invBot:10 };

  function drawSprite(sprite, x, y, color="#20ff6c", scale=PX){
    ctx.fillStyle=color; for(let r=0;r<sprite.length;r++){ const row=sprite[r]; for(let c=0;c<row.length;c++){ if(row[c]==='1') ctx.fillRect(Math.round(x + c*scale), Math.round(y + r*scale), scale, scale); }} }
  function spriteToPixels(sprite){ const w=sprite[0].length, h=sprite.length; const arr=new Array(w*h).fill(0); for(let r=0;r<h;r++) for(let c=0;c<w;c++) if(sprite[r][c]==='1') arr[r*w+c]=1; return {pixels:arr,w,h}; }

  function resetShields(){ state.shields=[]; const baseY = H - 70; const anchors=[W*0.18, W*0.5, W*0.82]; for(const gx of anchors){ const {pixels,w,h}=spriteToPixels(SPRITES.shield); for(let r=h-2;r<h;r++) for(let c=0;c<w;c++) if(r===h-1 && (c<2 || c>w-3)) pixels[r*w+c]=0; state.shields.push({x: Math.round(gx - w*PX/2), y: baseY, pixels, w, h}); } }

  function initFleet(){ const f=state.fleet; f.alive=[]; f.aliveCount=f.cols*f.rows; f.dir=1; f.stepIndex=0; f.lastStep=0; f.left=48; f.top=48; for(let r=0;r<f.rows;r++){ f.alive[r]=[]; for(let c=0;c<f.cols;c++){ const type=r===0? 'invTop' : (r<3? 'invMid' : 'invBot'); f.alive[r][c]={alive:true,type}; }} updateStepInterval(); }
  function updateStepInterval(){ const alive=state.fleet.aliveCount; const t=420 - (alive<=55? (55-alive)*6 : 0); state.fleet.stepInterval=Math.max(60,t); }

  function startGame(){
    Audio.ensure(); Audio.unlock();
    state.score=0; state.lives=3; state.level=1; state.enemyBullets=[]; state.bullets=[]; state.player.dead=false; state.player.x=W/2; state.player.reload=0; state.paused=false; state.frame=0; initFleet(); resetShields(); spawnSaucer(true);
    ui.hiscore.textContent = pad(state.hiscore,4); ui.score.textContent = pad(state.score,4); ui.lives.textContent = state.lives; ui.status.textContent = 'READY'; ui.marquee.classList.add('hidden'); state.running = true; lastPerf = performance.now(); requestAnimationFrame(loop);
  }
  function nextLevel(){ state.level++; initFleet(); resetShields(); state.enemyBullets=[]; state.bullets=[]; ui.status.textContent = `STAGE ${state.level}`; }
  function pad(n,len){ return String(n).padStart(len,'0'); }

  // Keyboard
  addEventListener('keydown', (e)=>{ if(e.code==='ArrowLeft') state.keys.left=true; if(e.code==='ArrowRight') state.keys.right=true; if(e.code==='Space'){ state.keys.shoot=true; e.preventDefault(); } if(e.key==='p' || e.key==='P'){ if(state.running){ state.paused=!state.paused; ui.status.textContent=state.paused?'PAUSED':'PLAY'; } } if(e.key==='r' || e.key==='R'){ if(!state.running) startGame(); } });
  addEventListener('keyup', (e)=>{ if(e.code==='ArrowLeft') state.keys.left=false; if(e.code==='ArrowRight') state.keys.right=false; if(e.code==='Space') state.keys.shoot=false; });
  ui.startBtn.addEventListener('click', startGame, {passive:true});

  // Touch controls (buttons)
  function bindHold(btn, on, off){ let holding=false; btn.addEventListener('pointerdown', (e)=>{ holding=true; on(); btn.setPointerCapture(e.pointerId); }, {passive:true}); btn.addEventListener('pointerup', ()=>{ holding=false; off(); }, {passive:true}); btn.addEventListener('pointercancel', ()=>{ holding=false; off(); }, {passive:true}); btn.addEventListener('lostpointercapture', ()=>{ holding=false; off(); }, {passive:true}); }
  bindHold(ui.leftBtn, ()=>state.keys.left=true, ()=>state.keys.left=false);
  bindHold(ui.rightBtn, ()=>state.keys.right=true, ()=>state.keys.right=false);
  bindHold(ui.fireBtn, ()=>state.keys.shoot=true, ()=>state.keys.shoot=false);

  // Direct canvas gestures: left 35% = LEFT, right 35% = RIGHT, middle = FIRE
  canvas.addEventListener('pointerdown', (e)=>{ const rect=canvas.getBoundingClientRect(); const x=e.clientX-rect.left; const zone=x/rect.width; if(zone<0.35){ state.keys.left=true; } else if(zone>0.65){ state.keys.right=true; } else { state.keys.shoot=true; } canvas.setPointerCapture(e.pointerId); }, {passive:true});
  canvas.addEventListener('pointerup', ()=>{ state.keys.left=false; state.keys.right=false; state.keys.shoot=false; }, {passive:true});
  canvas.addEventListener('pointercancel', ()=>{ state.keys.left=false; state.keys.right=false; state.keys.shoot=false; }, {passive:true});

  // Saucer
  function spawnSaucer(force=false){ const s=state.saucer; s.active=false; s.timer = force? 300 : 900 + Math.random()*900; }
  function updateSaucer(dt){ const s=state.saucer; if(!s.active){ s.timer -= dt*1000; if(s.timer<=0){ s.active=true; s.dir = Math.random()<0.5? 1 : -1; s.x = s.dir>0? -s.w*PX-5 : W+5; Audio.saucer(); } } else { s.x += 1.0 * s.dir; if((s.dir>0 && s.x>W+10) || (s.dir<0 && s.x<-40)) spawnSaucer(); } }

  // Discrete march timing
  let lastPerf = 0;
  function loop(t){ if(!state.running) return; requestAnimationFrame(loop); const dt = Math.min(1/30, (t-lastPerf)/1000||0); lastPerf=t; if(state.paused){ draw(); return; }
    state.frame++;
    const p = state.player;
    if(!p.dead){ if(state.keys.left)  p.x -= p.speed* (60*dt); if(state.keys.right) p.x += p.speed* (60*dt); p.x = Math.max(16, Math.min(W-16, p.x)); if(p.reload>0) p.reload--; if(state.keys.shoot && p.reload<=0){ state.bullets.push({x:p.x, y:p.y-10, v:-3.6, w:2, h:6, from:'player'}); p.reload = 18; Audio.playerShot(); } } else { if(state.frame % 90 === 0) p.dead=false; }
    for(const b of state.bullets) b.y += b.v; state.bullets = state.bullets.filter(b=> b.y>-20 && b.y<H+20);
    for(const b of state.enemyBullets) b.y += b.v; state.enemyBullets = state.enemyBullets.filter(b=> b.y<H+20);
    marchStep(dt); handleCollisions(); updateSaucer(dt); if(isFleetCleared()) nextLevel(); if(reachedBottom()) killPlayer(); draw(); }

  function marchStep(dt){ const f=state.fleet; const now=performance.now(); if(now - f.lastStep >= f.stepInterval){ f.lastStep=now; const b=fleetBounds(); let drop=false; if(b){ if((f.dir>0 && b.right + 2*PX > W-16) || (f.dir<0 && b.left - 2*PX < 16)){ f.dir*=-1; drop=true; } } if(drop) f.top += 8; else f.left += f.dir * 6; Audio.marchStep(++f.stepIndex, f.aliveCount); if(Math.random() < Math.min(0.6, 0.08 + (55 - f.aliveCount)*0.007)) shootFromFleet(); } }

  function fleetBounds(){ const f=state.fleet; let left=Infinity, right=-Infinity, top=Infinity, bottom=-Infinity, any=false; for(let r=0;r<f.rows;r++) for(let c=0;c<f.cols;c++){ const cell=f.alive[r][c]; if(cell&&cell.alive){ any=true; const x=f.left + c*22; const y=f.top + r*16; left=Math.min(left,x); right=Math.max(right,x+16); top=Math.min(top,y); bottom=Math.max(bottom,y+12); }} return any? {left,right,top,bottom} : null; }

  function shootFromFleet(){ const f=state.fleet; const columns=[]; for(let c=0;c<f.cols;c++){ for(let r=f.rows-1;r>=0;r--){ const cell=f.alive[r][c]; if(cell?.alive){ columns.push({r,c}); break; } } } if(columns.length===0) return; const pick=columns[Math.floor(Math.random()*columns.length)]; const x=f.left + pick.c*22 + 8; const y=f.top + pick.r*16 + 10; state.enemyBullets.push({x,y,v: 1.8 + Math.random()*0.8, w:2, h:6, from:'enemy'}); }

  function isFleetCleared(){ return state.fleet.aliveCount===0; }
  function reachedBottom(){ const b=fleetBounds(); return b && b.bottom >= state.player.y-6; }
  function killPlayer(){ if(state.player.dead) return; state.player.dead=true; state.lives--; ui.lives.textContent=state.lives; Audio.playerExplode(); if(state.lives<0) gameOver(); else { state.bullets=[]; state.enemyBullets=[]; ui.status.textContent='HIT!'; } }
  function gameOver(){ state.running=false; ui.status.textContent='GAME OVER'; ui.marquee.classList.remove('hidden'); ui.marquee.querySelector('h1').textContent='GAME OVER'; ui.startBtn.textContent='INSERT COIN • RESTART'; }
  function addScore(n){ state.score += n; if(state.score>state.hiscore){ state.hiscore=state.score; localStorage.setItem('si_hiscore', String(state.hiscore)); } ui.score.textContent=pad(state.score,4); ui.hiscore.textContent=pad(state.hiscore,4); }

  function handleCollisions(){ for(const b of state.bullets){ if(state.saucer.active && rects(b,{x:state.saucer.x, y:state.saucer.y, w:SPRITES.saucer[0].length*PX, h:SPRITES.saucer.length*PX})) { state.saucer.active=false; spawnSaucer(); b.y=-9999; addScore(saucerMysteryScore()); Audio.saucerHit(); } const hit=bulletHitsInvader(b); if(hit){ b.y=-9999; addScore(SCORE_BY_TYPE[hit.type]); Audio.invaderExplode(); } hitShield(b); } for(const eb of state.enemyBullets){ if(rects(eb,{x:state.player.x-8, y:state.player.y-6, w:16, h:10})) { eb.y=H+999; killPlayer(); } hitShield(eb); } }

  function bulletHitsInvader(b){ const f=state.fleet; for(let r=f.rows-1;r>=0;r--) for(let c=0;c<f.cols;c++){ const cell=f.alive[r][c]; if(!cell?.alive) continue; const x=f.left + c*22; const y=f.top + r*16; const w=16,h=12; if(rects(b,{x,y,w,h})) { cell.alive=false; f.aliveCount--; updateStepInterval(); return cell; } } return null; }

  function hitShield(b){ for(const s of state.shields){ const relx=Math.floor((b.x - s.x)/PX), rely=Math.floor((b.y - s.y)/PX); for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){ const cx=relx+dx, cy=rely+dy; if(cx<0||cy<0||cx>=s.w||cy>=s.h) continue; const idx=cy*s.w + cx; if(s.pixels[idx]===1){ s.pixels[idx]=0; b.y=-9999; } } } }

  function rects(a,b){ return a.x-a.w/2 < b.x+b.w && a.x+a.w/2 > b.x && a.y-a.h/2 < b.y+b.h && a.y+a.h/2 > b.y; }

  let shotsFired=0; function saucerMysteryScore(){ shotsFired++; const table=[100,50,50,100,150,50,100,50,300,100,50,150,100,50,50]; return table[shotsFired % table.length]; }

  // Drawing
  function draw(){ ctx.clearRect(0,0,W,H); ctx.fillStyle='#013'; for(let i=0;i<60;i++) ctx.fillRect((i*79 + state.frame*0.3)%W, (i*43 + Math.sin((state.frame+i)*0.02)*2)%H, 1, 1);
    for(const s of state.shields){ for(let r=0;r<s.h;r++) for(let c=0;c<s.w;c++) if(s.pixels[r*s.w+c]===1){ ctx.fillStyle='#24ff88'; ctx.fillRect(s.x + c*PX, s.y + r*PX, PX, PX); } }
    const p=state.player; if(!p.dead) drawSprite(SPRITES.player, p.x- (SPRITES.player[0].length*PX)/2, p.y- (SPRITES.player.length*PX)/2); else drawSprite(SPRITES.boom, p.x-3, p.y-3, '#ff4d4d', PX+1);
    const f=state.fleet; for(let r=0;r<f.rows;r++) for(let c=0;c<f.cols;c++){ const cell=f.alive[r][c]; if(!cell?.alive) continue; const x=f.left + c*22, y=f.top + r*16; const sprite = cell.type==='invTop'? SPRITES.invTop : cell.type==='invMid'? SPRITES.invMid : SPRITES.invBot; drawSprite(sprite, x, y); }
    ctx.fillStyle='#20ff6c'; for(const b of state.bullets) ctx.fillRect(Math.round(b.x-1), Math.round(b.y-6), 2, 6);
    ctx.fillStyle='#ff3b3b'; for(const b of state.enemyBullets) ctx.fillRect(Math.round(b.x-1), Math.round(b.y-2), 2, 6);
    if(state.saucer.active) drawSprite(SPRITES.saucer, state.saucer.x, state.saucer.y, '#d6ff52');
    ctx.fillStyle='#093'; ctx.fillRect(12, H-40, W-24, 1);
  }

  // Pause when tab hidden to save battery
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ state.paused=true; ui.status.textContent='PAUSED'; } });

  // Boot
  ui.hiscore.textContent = pad(state.hiscore,4);
})();
</script>
</body>
</html>
